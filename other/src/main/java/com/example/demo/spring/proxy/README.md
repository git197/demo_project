#静态代理
1. 必须有一个特定的接口
2. 代理类和被代理类要同时实现特定的接口
3. 代理必须包含真是的对象

##什么时候加载的
在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。

`优点：`

业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理的共有优点。

`缺点：`
1. 代理对象的一个接口只服务于一种类型的对象
    >比如购票时代理类代理了南方航空共就无法代理东方航空
2. 如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。

另外，如果要按照上述的方法使用代理模式，那么真实角色(委托类)必须是事先已经存在的，并将其作为代理对象的内部属性。但是实际使用时，一个真实角色必须对应一个代理角色，如果大量使用会导致类的急剧膨胀；此外，如果事先并不知道真实角色（委托类），该如何使用代理呢？这个问题可以通过Java的动态代理类来解决。

#动态代理
1. 一个特定接口
2. 一个自己的实现类
3. 一个`Handler` 实现`InvocationHandler`接口,重写`invoke`方法(invoke不是显示调用的,可以在这里面实现一些增强逻辑)

##原理
 每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用 一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。
`优点`  
减少编程的工作量：假如需要实现多种代理处理逻辑，只要写多个代理处理器就可以了，无需每种方式都写一个代理类。
系统扩展性和维护性增强，程序修改起来也方便多了(一般只要改代理处理器类就行了)。

`不足`  
目前根据GOF的代理模式，代理类和委托类需要都实现同一个接口(在代理类实例化时需传入目标接口)。也就是说只有实现了某个接口的类可以使用Java动态代理机制。但是，事实上使用中并不是遇到的所有类都会给你实现一个接口。因此，对于没有实现接口的类，目前无法使用该机制。
